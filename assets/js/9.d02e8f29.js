(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{593:function(e,t,a){e.exports=a.p+"assets/img/rabbitmq-message-send.6895a77c.jpg"},594:function(e,t,a){e.exports=a.p+"assets/img/rabbitmq-conversation.301a13e1.jpg"},595:function(e,t,a){e.exports=a.p+"assets/img/amqp-frame.194d4102.jpg"},596:function(e,t,a){e.exports=a.p+"assets/img/Basic-properties.4cce1931.png"},617:function(e,t,a){"use strict";a.r(t);var r=a(17),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("rabbitmq是一款被广泛使用的消息队列中间件，它目前被Pivotal公司所拥有。其基于"),r("code",[e._v("AMQM")]),e._v("、"),r("code",[e._v("AMQP")]),e._v("并用"),r("code",[e._v("erlang")]),e._v("语言实现，拥有诸多特性，譬如开源、强大商业支持、跨语言、跨平台、轻量级、扩展性强、可定制、安全支持等。它可以通过分布式部署满足高可用的需求，其吞吐量亦十分可观，能够达到万/s的级别，当然吞吐量的高的代价是比较吃cpu，我们可以根据自身系统在可用性和性能两方面做权衡。另外rabbitmq还支持异地多活和异地多活多主架构。\nrabbitmq强悍的力量很大程度上是因为其基于"),r("code",[e._v("AMQP")]),e._v("，"),r("code",[e._v("AMQP")]),e._v("不仅定义了网络层协议而且对服务端的服务和行为也做了定义，即"),r("code",[e._v("AMQ model")]),e._v("。"),r("code",[e._v("AMQ model")]),e._v("就消息路由行为定义了三个抽象组件："),r("code",[e._v("Exchange,Queue,Binding")]),e._v("。")]),e._v(" "),r("ul",[r("li",[e._v("Exchange：将消息路由给队列的组件")]),e._v(" "),r("li",[e._v("Queue：存在于内存或者磁盘中的存储消息的数据结构")]),e._v(" "),r("li",[e._v("Binding：Exchange将消息分发给Queue的规则")])]),e._v(" "),r("p",[e._v("将一个message发送到broker后，broker的行为如下图所示：")]),r("div",{attrs:{align:"center"}},[r("img",{attrs:{src:a(593)}})]),r("p"),e._v(" "),r("p",[e._v("实际使用时，每种Exchange类型处理routing-key的行为会有所差异，有的不做任何处理，有些则需要进行复杂的模式匹配提取，header exchange甚至根本就不管routing-key是啥。rabbitmq在设计中扩展了AMQ model，exchange不仅接受queue的绑定，而且接受其他exchange的绑定，这种特性为消息的路由模式提供了相当的灵活性。")]),e._v(" "),r("p",[e._v("rabbitmq客户端库的实现都会隐藏掉基于AMQP进行通信的复杂性，这或许对用户来说是一件好事，用户的绝大多数精力可以用在应用层上，不必关心实际上的复杂性。但我们还是应当熟悉AMQP协议，只有这样，我们才不会在应用性能没有达到预期或者是出现错误时束手无策。")]),e._v(" "),r("p",[e._v("rabbitmq利用"),r("code",[e._v("RPC")]),e._v("模式实现AMQP的通信，但是具体实现又同一般的RPC模式有所不同。一般来说，进行RPC通信的双方，客户端发送指令给服务端，服务端处理后返回响应，这里服务端是不会发指令给客户端的，但是rabbitmq的RPC实现中，服务端会。")]),r("div",{attrs:{align:"center"}},[r("img",{attrs:{src:a(594),height:"600px"}})]),r("p"),e._v(" "),r("p",[e._v("rabbitmq客户端与服务端之间建立通信首先需要经过三次握手。首先客户端会发送包含Protocol Header的Greeting给服务端，接着服务端发送Connection.Start给客户端，最后客户端发送Connection.StartOk给服务端，之后一个连接就建立了。在客户端与服务端之间进行有实际意义的交流之前，还得在连接中打开channel，在channel中进行AMQP帧的传输。channel是双工的，并且可以在一个连接中有多个，有点像HTTP2。")]),e._v(" "),r("p",[e._v("AMQP的命令由类和方法组成，像Connection.Start中，Connection是对象，Start是方法。当命令被发送到客户端或者服务端时，执行命令所需的参数被封装到帧中进行传输。底层的AMQP帧大致上长这样。")]),r("div",{attrs:{align:"center"}},[r("img",{attrs:{src:a(595)}})]),r("p"),e._v(" "),r("p",[e._v("帧的头部由帧类型，channe编码，payload大小组成。有五种帧的类型如下所示：")]),e._v(" "),r("ul",[r("li",[e._v("protocol header frame：只会在在连接到rabbitmq时用到")]),e._v(" "),r("li",[e._v("method frame：携带RPC请求或者响应")]),e._v(" "),r("li",[e._v("content header frame：包含消息的大小和属性")]),e._v(" "),r("li",[e._v("body frame：消息内容")]),e._v(" "),r("li",[e._v("heartbeat frame：心跳检测确认通信双方存活")])]),e._v(" "),r("p",[e._v("在channel中的数据总是以"),r("code",[e._v("method frame")]),e._v("，"),r("code",[e._v("content header frame")]),e._v("，多个"),r("code",[e._v("body frame")]),e._v("的顺序流动。method frame被特殊编码以压缩大小，典型的method frame头两个字段包含类型和方法，之后的一个字段是exchange name，再然后是routing-key，最后可能会有一个mandatory字段以让rabbitmq在没有满足消息发布需求时给客户端进行反馈。content header frame的payload主体由Basic.Properties表组成，通过它可以很方便的实现消息的定制化。content header frame也会被特殊编码。body frame则不会被特殊编码，它可以装载各种格式的图片，json/xml格式数据或者是文档等。")]),e._v(" "),r("p",[e._v("在AMQ model中，"),r("code",[e._v("exchange")]),e._v("和"),r("code",[e._v("queue")]),e._v("都是一等公民。创建一个exchange对应的method是Exchange.Declare,如果创建成功，rabbitmq会返回Exchange.DeclareOk,否则会返回Channel.Close。类似的，创建一个queue对应的method是Queue.Declare,如果创建成功，rabbitmq会返回Queue.DeclareOk,否则会返回Channel.Close。将一个queue绑定到exchange的method是Queue.Bind,绑定成功，rabbitmq会返回Queue.BindOk。以上的method在AMQP中都是同步命令，在AMQP中也有一些命令通过异步的方式来接受和发送消息。")]),e._v(" "),r("p",[e._v("当我们通过Basic.Publish发布消息到rabbitmq中时，可以将消息存储到内存或者是磁盘中去，并且只会储存一份，丢到队列中的实际是实例的一份引用，不同队列的实例引用之间互不影响。当我们把消息丢到队列中去之后，剩下的就是消费了，客户端发送Basic.Consume请求消费，然后rabbitmq响应Basic.ConsumeOk表示可以开始消费，若客户端想要终止消费过程，可以发送Basic.Cancel,这是一个异步命令，所以客户端此时还是会收到rabbitmq发来的消息。")]),e._v(" "),r("p",[e._v("受限于精力，能力和时间成本，rabbitmq的AMQP实现的了解暂时先到此为止。如果想进一步了解，可以参考"),r("a",{attrs:{href:"https://www.rabbitmq.com/protocol.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("rabbitmq的官方文档"),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("p",[e._v("附上Basic.Properties的属性表：")]),r("div",{attrs:{align:"center"}},[r("img",{attrs:{src:a(596)}})]),r("p")])}),[],!1,null,null,null);t.default=n.exports}}]);