(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{591:function(e,r,a){e.exports=a.p+"assets/img/performance-with-guarantee.030c6e54.png"},592:function(e,r,a){e.exports=a.p+"assets/img/consume-with-guarantee.b960678f.png"},616:function(e,r,a){"use strict";a.r(r);var c=a(17),s=Object(c.a)({},(function(){var e=this,r=e.$createElement,c=e._self._c||r;return c("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[c("blockquote",[c("p",[e._v("多一分则肥，少一分则瘦")])]),e._v(" "),c("p",[e._v("消息中间件消息的发布需要在高性能与可靠性之间做权衡，rabbitmq依靠AMQP的事务规范，可选的持久化机制，以及自身的传输确认机制为我们构建不同等级的可靠系统提供了可能性。")]),c("div",{attrs:{align:"center"}},[c("img",{attrs:{src:a(591)}})]),c("p"),e._v(" "),c("p",[e._v("Notification on failure -- 当我们在Basic.Publish的method frame中添加mandatory标志时，如果消息没有被正确的路由，那么rabbitmq broker就会通过Basic.Return的RPC回传消息给publisher。在我们的代码中要注册回调函数处理这种路由失败的情况。Publisher confirms -- publisher发送Confirm.Select,rabbitmq broker回复Confirm.SelectOk，之后这条传递消息的channel就成了一个confirm channel，publisher每发送一条消息给服务器，如果消息都入队等待被消费并且被持久化到磁盘中，或者是消息在所有应该路由到的队列中都被消费者消费完毕了，服务端就会回复Basic.Ack，否则就会回复Basic.Nak。服务端异步回复confirm消息，在我们的代码中需要注册回调函数处理来自服务端的回复。Alternate exchanges -- 当我们声明一个exchange，可以给它绑定一个备用exchange，当发送给给此exchange的消息无法被路由时，此备选exchange就会接管工作，将消息路由到死信队列中去，值得注意的是，一旦同时设置mandatory标志和备选队列，那么mandatory就失效了。Transactions -- AMQP规范中定义了事务来保证批处理的原子性。publisher发送TX.Select,服务端回传TX.SelectOk，事务就开始了，可以在事务中发送一条或者多条消息，消息发送完毕publisher发送TX.Commit，然后在收到服务端的TX.CommitOk后，事务就完成了。这里需要注意的是当事务执行过程中，发生错误了，那么服务端就会发送Basic.Return,publisher如果想终止事务，可以发送TX.Rollback，然后等待服务端回传TX.RollbackOk。另外，rabbitmq在实现AMQP事务规范时只有当命令只影响一条队列时，才保证其原子性，当有多条队列收到影响时，原子性就会被打破。事务机制比较影响性能。HA queues -- HA queue需要在集群环境中使用，在定义队列时，将队列声明为高可用队列，模式若设为all，则集群中的所有结点都会同步此队列的状态。若模式为nodes，则可自定义同步节点。一旦消费者在任意节点消费了此队列中的消息，所有节点中的该条消息就会立刻被删除。HA queues拥有一个主节点，其他的都是副节点，如果主节点挂了，其他的某个副节点就会成为新的主节点。如果挂了的节点恢复了，或者集群中加入了新的节点，那么它们会接受新发送来的消息，并且在队列中的旧消息都消费完毕了才会加入同步集。HA queues with transactions -- 这种方式会引入相当的响应延迟，慎重使用。Persisted messages -- 持久化选项由Basic.Properties中的delivery-mode控制，默认为1，表示不持久化，如果想要持久化，则应该设为2，另外装此消息的队列也应该被设置为持久化队列。")]),e._v(" "),c("p",[e._v("上面一段讲了向rabbitmq发布消息的问题，这一段我们看看怎么从rabbitmq获取消息。有两种方法可以从rabbitmq获取消息，"),c("code",[e._v("Basic.Get")]),e._v(" & "),c("code",[e._v("Basic.Consume")]),e._v("。Basic.Get使用一种拉的模式从broker中获取消息，consumer想要获取一个消息都必须发送一个新的Basic.Get RPC请求，broker会根据queue中是否有代办消息回复"),c("code",[e._v("Basic.GetOk")]),e._v(" or "),c("code",[e._v("Basic.GetEmpty")]),e._v("，消费端需要根据回复进行相应的处理。Basic.Get的这种同步方式对性能有明显的影响，更重要的是，由于consume是消费端主动发起的，所以broker也无法优化整个传输过程。与"),c("code",[e._v("Basic.Get")]),e._v("相反的是，"),c("code",[e._v("Basic.Consume")]),e._v("以一种推的方式从broker中获取消息，发送Basic.Consume RPC请求到broker后，rabbitmq就会在broker中注册你的应用，然后直到你发送"),c("code",[e._v("Basic.Cancel")]),e._v("之前,broker都以一种异步的方式将队列中的消息发送给消费者。当然从broker获取到消息之后，消费端也需要向broker发送"),c("code",[e._v("Basic.Ack")]),e._v("让它知道消息已经被正常消费了。同publish一样，消费消息也需要在吞吐量和可靠性之间做权衡。")]),c("div",{attrs:{align:"center"}},[c("img",{attrs:{src:a(592)}})]),c("p"),e._v(" "),c("p",[e._v("no-ack -- 当向rabbitmq发送Basic.Consume注册我们的应用进行消费时，在请求中携带no-ack的标志时，broker就会知道消费端不会ack，应该尽可能快速地将消息发送给消费端。Consuming with acknowledgement and Qos > 1 -- 通过向broker发送Basic.Qos请求，我们可以设置一条channel的服务质量，broker会在这条channel上连续发送预设数量的message后，等待消费端的回复，消费端可以选择依旧每条消息都回复，也可以通过在Basic.Ack中设置multiple标志而不必每条消息都回复，broker会将没有收到回复的消息写回到队列中。当然设置multiple标志的方式会有重复消费的风险。transaction -- 事务方式可以规避重复消费的风险，代价是吞吐量不及QoS的方式。")]),e._v(" "),c("p",[e._v("当消费端在接收消息或者处理消息的过程中发生异常情况时，rabbitmq提供两种方式将消息踢还给broker："),c("code",[e._v("Basic.Reject")]),e._v(" & "),c("code",[e._v("Basic.Nak")]),e._v("。发送Basic.Reject给服务端时，若在请求中携带requeue标志，则broker会将消息重新入队，否则broker只是简单的将消息丢弃。Basic.Nak的行为与Basic.Reject类似，不同的是其类似Basic.Ack可以在一次回复中携带多个拒绝信息，它也不是AMQP原生支持的命令。除了这两条命令，rabbitmq还提供叫做死信exchange(DLX)的扩展，DLX同队列进行绑定，一个队列中被拒绝且没有重新入队的消息或者过期的消息会被交给DLX。")])])}),[],!1,null,null,null);r.default=s.exports}}]);