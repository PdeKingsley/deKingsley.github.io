(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{611:function(t,e,n){"use strict";n.r(e);var _=n(17),a=Object(_.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("字节码技术是虚拟机实现平台无关性，语言无关性的基石，得益于此，Java语言才能在嵌入式，web服务端等领域大展拳脚并受到长期欢迎。围绕字节码技术，发展出一批拥有不同特性的运行于Java虚拟机之上的编程语言，如groovy，Scala，kotlin等。虚拟机只与class文件绑定，它不关心class文件来自何处，是来自本地的磁盘文件，还是来自于网络，是由.java文件编译而来，还是由.groovy文件编译而来，只要是有效的class文件，虚拟机便能够运行。")]),t._v(" "),n("p",[t._v("一个class文件由连续的8-bit、16-bit和32-bit的无符号数的流构成，并且以大端模式存储。class文件的格式可以以一种C-like结构体的方式描述，结构体由"),n("code",[t._v("items")]),t._v("和"),n("code",[t._v("tables")]),t._v("构成。tables由零个或者任意的items构成。class文件的格式结构体描述如下，其中u1，u2，u4为"),n("code",[t._v("items")]),t._v(",_info结尾的项为"),n("code",[t._v("tables")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("ClassFile{\n    u4              magic;\n    u2              minor_version;\n    u2              major_version;\n    u2              constant_pool_count;\n    cp_info         constant_pool[constant_pool_count-1];\n    u2              access_flags;\n    u2              this_class;\n    u2              super_class;\n    u2              interfaces_count;\n    u2              interfaces[interfaces_count];\n    u2              fields_count;\n    field_info      fields[fields_count];\n    u2              methods_count;\n    method_info     methods[methods_count];\n    u2              attributes_count;\n    attribute_info  attributes[attributes_count];\n}\n")])])]),n("blockquote",[n("p",[t._v("magic")])]),t._v(" "),n("p",[t._v("魔数，固定为OxCAFEBABE,标志为一个class文件。")]),t._v(" "),n("blockquote",[n("p",[t._v("minor_version,major_version")])]),t._v(" "),n("p",[t._v("它们共同决定了一个class文件的版本，不同的Java SE所能支持的class文件版本是不同的，比如Java8支持主版本45-52，Java18支持主版本45-62。主版本号 >= 56时，此版本号限制为0或者65535，之前的主版本则随意。Java虚拟机的实现如果遵循JavaSE的某版本(>=12)，那么就必须支持该版本的preview feature，并且默认关闭支持，但是提供途径可以开启支持。一个class文件的版本若为(45 - N+44).65535的形式，则其是依赖JavaSEN的preview feature的class文件。一个遵循JavaSEN的虚拟机实现，只有在开启preview feature支持时，才能加载(45 - N+44).65535的class文件，普通的则不受影响。")]),t._v(" "),n("blockquote",[n("p",[t._v("constant_pool_count")])]),t._v(" "),n("p",[t._v("常量池条目的数量加一。")]),t._v(" "),n("blockquote",[n("p",[t._v("constant_pool[]")])]),t._v(" "),n("p",[t._v("常量池是一张可包含各种字符串常量，类名，接口名，字段名以及其他表示class文件中条目的常量的表，表中entry的格式由其第一个字节"),n("code",[t._v("tag")]),t._v("指示。常量表的索引从1到constant_pool_count - 1。")]),t._v(" "),n("blockquote",[n("p",[t._v("access_flags")])]),t._v(" "),n("p",[t._v("access_flags是一个掩码标记，用来指示一个类或者接口的访问权限以及各种属性。")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",{staticStyle:{"text-align":"left"}},[t._v("Flag name")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("Value")]),t._v(" "),n("th",{staticStyle:{"text-align":"left"}},[t._v("Interpretation")])])]),t._v(" "),n("tbody",[n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("ACC_PUBLIC")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("0x0001")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("Declared public; may be accessed from outside its package.")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("ACC_FINAL")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("0x0010")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("Declared final; no subclasses allowed")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("ACC_SUPER")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("0x0020")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("Treat superclass methods specially when invoked by the invokespecial instruction")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("ACC_INTERFACE")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("0x0200")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("Is an interface, not a class")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("ACC_ABSTRACT")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("0x0400")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("Declared abstract; must not be instantiated")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("ACC_SYNTHETIC")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("0x1000")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("Declared synthetic; not present in the source code.")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("ACC_ANNATATION")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("0x2000")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("Declared as an annotation interface.")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("ACC_ENUM")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("0x4000")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("Declared as an enum class.")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("ACC_MODULE")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("0x8000")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("Is a module, not a class or interface.")])])])]),t._v(" "),n("p",[t._v("ACC_SUPER用来指示当遇到invokespecial指令将表示的两种语义时，应该选择哪种进行解释。Java8之后，无论class文件是否设置该值，虚拟机都认为设置了。ACC_SYNTHETIC指示该类或者接口是由编译器动态生成的，而不是本身就存在于源码中的。")]),t._v(" "),n("blockquote",[n("p",[t._v("this_class")])]),t._v(" "),n("p",[t._v("该值是常量池表的一个有效索引，索引指向的条目必须是一个代表该类或者接口结构的"),n("code",[t._v("CONSTANT_Class_info")]),t._v("类型。")]),t._v(" "),n("blockquote",[n("p",[t._v("super_class")])]),t._v(" "),n("p",[t._v("该值或为0或为指向常量池的一个有效索引，若为0，则超类为Object，否则指向常量池中一个代表超类结构的"),n("code",[t._v("CONSTANT_Class_info")]),t._v("类型。")]),t._v(" "),n("blockquote",[n("p",[t._v("interfaces_count")])]),t._v(" "),n("p",[t._v("代表该类或者接口有几个直接父接口。")]),t._v(" "),n("blockquote",[n("p",[t._v("interfaces[]")])]),t._v(" "),n("p",[t._v("一个指向常量池的有效索引的数组，每个索引指向的条目必须是代表父接口结构的"),n("code",[t._v("CONSTANT_Class_info")]),t._v("类型。")]),t._v(" "),n("blockquote",[n("p",[t._v("fields_count")])]),t._v(" "),n("p",[t._v("指示该类或接口的类变量和实例变量的总数目。")]),t._v(" "),n("blockquote",[n("p",[t._v("fields[]")])]),t._v(" "),n("p",[t._v("字段表的每个条目必须是"),n("code",[t._v("field_info")]),t._v("结构，用来表示一个字段的完整描述。")]),t._v(" "),n("blockquote",[n("p",[t._v("methods_count")])]),t._v(" "),n("p",[t._v("指示该类或者接口有多少方法。")]),t._v(" "),n("blockquote",[n("p",[t._v("methods[]")])]),t._v(" "),n("p",[t._v("方法表的每个条目必须是"),n("code",[t._v("method_info")]),t._v("结构，用来表示一个方法的完整描述。如果结构中没有设置"),n("code",[t._v("ACC_NATIVE")]),t._v("或者"),n("code",[t._v("ACC_ABSTRACT")]),t._v("，那么方法的虚拟机指令实现也会被提供。")]),t._v(" "),n("blockquote",[n("p",[t._v("attributes_count")])]),t._v(" "),n("p",[t._v("指示该类属性的总数目。")]),t._v(" "),n("blockquote",[n("p",[t._v("attributes[]")])]),t._v(" "),n("p",[t._v("属性表的每个条目必须是"),n("code",[t._v("attribute_info")]),t._v("结构，用来表示一个属性的完整描述。属性表条目可以用来表示class文件的属性，也可以用来表示一个方法的属性。"),n("code",[t._v("attribute_info")]),t._v("的结构如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("attribute_info {\n    u2 attribute_name_index; \n    u4 attribute_length; \n    u1 info[attribute_length];\n}\n")])])]),n("p",[t._v("常量池表是class文件的资源仓库，与class文件中的其他item有着各种各样的联系。常量池表的第0号索引被空出来，用来在表示不引用任何常量池item的特殊含义。常量池中主要有两类常量：字面量和符号引用，字面量接近Java语言层面的常量概念，符号引用则属于编译原理方面的概念，主要包括package、Fully Qualified Name、Descriptor、Method Handle、Method Type、Invoke Dynamic、Dynamically-Computed Call Site、Dynamically-Computed Constant。")]),t._v(" "),n("p",[t._v("类或者接口的名称在class文件中总是被表示为全限定类名的utf8编码形式，放在常量池的"),n("code",[t._v("CONSTANT_Utf8_info")]),t._v("结构中。而方法，字段，本地变量，形参则为非全限定类名的Unicode编码方式。")]),t._v(" "),n("p",[t._v("类中的字段和方法的类型被一个叫descriptor的字符串来表示，其在常量池中是一个"),n("code",[t._v("CONSTANT_Utf8_info")]),t._v("结构。字段描述符被表示为FieldDescriptor:FieldType。Object类型的字段的描述符为Ljava/lang/Object,double[][][]类型的字段的描述符为[[[D，array类型不能超过255个维度。方法描述符被表示为：MethodDescriptor:( {ParameterDescriptor} ) ReturnDescriptor，比如Object m(int i, double d, Thread t) {...}的描述符为(IDLjava/lang/Thread;)Ljava/lang/Object;。")]),t._v(" "),n("p",[t._v("常量池的每一项都是一个表，截至jdk18，共有17类表结构，这些表结构的第一项都是一个u1的tag，表示其是哪种类型的表结构。具体如下所示：")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",{staticStyle:{"text-align":"left"}},[t._v("Constant Kind")]),t._v(" "),n("th",{staticStyle:{"text-align":"left"}},[t._v("Tag")])])]),t._v(" "),n("tbody",[n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_Class")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("7")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_Fieldref")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("9")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_Methodref")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("10")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_InterfaceMethodref")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("11")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_String")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("8")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_Integer")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("3")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_Float")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("4")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_Long")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("5")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_Double")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("6")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_NameAndType")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("12")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_Utf8")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("1")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_MethodHandle")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("15")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_MethodType")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("16")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_Dynamic")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("17")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_InvokeDynamic")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("18")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_Module")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("19")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"left"}},[t._v("CONSTANT_Package")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("20")])])])]),t._v(" "),n("p",[t._v("所有类型的条目都遵循以下格式：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("cp_info { \n    u1 tag;\n    u1 info[]; \n}\n")])])]),n("ul",[n("li",[n("p",[t._v("CONSTANT_Class_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_Class_info {\n      // 7  \n      u1 tag;\n\n      // 指向常量池表的某一项，该项为CONSTANT_Utf8_info结构\n      // 存储类的全限定类名\n      u2 name_index;  \n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_Fieldref_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_Fieldref_info { \n      // 9\n      u1 tag;\n\n      // 指向常量池的某CONSTANT_Class_info结构\n      // 该结构可表示一个类或者接口\n      u2 class_index; \n\n      // 指向常量池的某CONSTANT_NameAndType_info结构\n      // 指示名称和字段描述符\n      u2 name_and_type_index; \n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_Methodref_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_Methodref_info { \n      // 10\n      u1 tag;\n\n      // 指向常量池的某CONSTANT_Class_info结构\n      // 该结构只能表示一个类\n      u2 class_index; \n\n      // 指向常量池的某CONSTANT_NameAndType_info结构\n      // 指示名称和方法描述符\n      u2 name_and_type_index; \n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_InterfaceMethodref_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_InterfaceMethodref_info { \n      // 11\n      u1 tag;\n\n      // 指向常量池的某CONSTANT_Class_info结构\n      // 该结构只能表示一个接口\n      u2 class_index; \n\n      // 指向常量池的某CONSTANT_NameAndType_info结构\n      // 指示名称和方法描述符\n      u2 name_and_type_index; \n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_String_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_String_info { \n      // 8\n      u1 tag;\n\n      // 指向常量池的一个CONSTANT_Utf8_info结构\n      // 该结构表示字符串对象的Unicode编码\n      u2 string_index; \n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_Integer_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_Integer_info {\n      // 3 \n      u1 tag; \n\n      // 表示int值\n      u4 bytes;\n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_Float_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_Float_info { \n      // 4 \n      u1 tag; \n\n      // 表示为IEEE754的单浮点数编码\n      u4 bytes;\n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_Long_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_Long_info { \n      // 5\n      u1 tag;\n\n      // 高位\n      u4 high_bytes;\n\n      // 低位 \n      u4 low_bytes;\n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_Double_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_Double_info { \n      // 6\n      u1 tag;\n\n      // 高位\n      u4 high_bytes;\n\n      // 低位 \n      u4 low_bytes;\n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_NameAndType_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_NameAndType_info { \n      // 12\n      u1 tag;\n\n      // 指向常量池的一个CONSTANT_Utf8_info\n      // 表示一个字段或者方法的名称\n      u2 name_index; \n\n      // 指向常量池的一个CONSTANT_Utf8_info\n      // 表示一个字段或者方法描述符\n      u2 descriptor_index;\n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_Utf8_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_Utf8_info { \n      // 1\n      u1 tag;\n\n      // byte数组的长度\n      u2 length; \n\n      // UTF-8编码\n      u1 bytes[length]; \n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_MethodHandle_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_MethodHandle_info { \n      // 15\n      u1 tag;\n\n      // 表示方法句柄的类型，该类型会影响字节码的行为\n      // 1.REF_getField 2.REF_getStatic 3.REF_putField\n      // 4.REF_putStatic 5.REF_invokeVirtual 6.REF_invokeStatic\n      // 7.REF_invokeSpecial 8.REF_newInvokeSpecial 9.REF_invokeInterface\n      u1 reference_kind; \n\n      // 根据reference_kind的值，指向常量池中的某CONSTANT_Fieldref_info\n\n      // CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info结构\n      u2 reference_index;\n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_MethodType_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_MethodType_info { \n      // 16\n      u1 tag;\n\n      // 指向常量池中的某表示方法描述符的CONSTANT_Utf8_info结构\n      u2 descriptor_index; \n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_Dynamic_info （表示一个动态调用计算出的常量）")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_Dynamic_info { \n      // 17\n      u1 tag;\n\n      // 指向attribute数组中bootstrap_methods数组的有效索引值\n      u2 bootstrap_method_attr_index; \n\n      // 指向常量池中的一个表示字段描述符的CONSTANT_NameAndType_info结构\n      u2 name_and_type_index;\n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_InvokeDynamic_info （表示一个动态计算出的方法调用）")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_InvokeDynamic_info { \n      // 18\n      u1 tag;\n\n      // 指向attribute数组中bootstrap_methods数组的有效索引值\n      u2 bootstrap_method_attr_index; \n\n      // 指向常量池中的一个表示方法描述符的CONSTANT_NameAndType_info结构\n      u2 name_and_type_index;\n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_Module_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_Module_info { \n      // 19\n      u1 tag;\n\n      // 指向常量池中一个表示模块名的CONSTANT_Utf8_info结构\n      u2 name_index; \n  }\n")])])])]),t._v(" "),n("li",[n("p",[t._v("CONSTANT_Package_info")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("  CONSTANT_Package_info {\n      // 20 \n      u1 tag;\n\n      // 指向常量池中一个表示包名的CONSTANT_Utf8_info结构\n      u2 name_index; \n  }\n")])])])])]),t._v(" "),n("p",[t._v("class文件中fields数组中的条目都遵循"),n("code",[t._v("field_info")]),t._v("结构，数组中的任意两个条目都不可能有相同的名称和描述符。field_info结构如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("field_info {\n    // 掩码标记，指示访问权限以及属性\n    // ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED\n    // ACC_STATIC、ACC_FINAL、ACC_VOLATILE\n    // ACC_TRANSIENT、ACC_SYNTHETIC、ACC_ENUM\n    u2 access_flags; \n\n    // 指向常量池中一个表示字段名的CONSTANT_Utf8_info结构\n    u2 name_index;\n\n    // 指向常量池中一个表示字段描述符的CONSTANT_Utf8_info结构\n    u2 descriptor_index; \n\n    // 字段额外属性数组的大小\n    u2 attributes_count;\n\n    // attribute_info结构的数组\n    attribute_info attributes[attributes_count]; \n}\n")])])]),n("p",[t._v("class文件中methods数组中的条目都遵循"),n("code",[t._v("method_info")]),t._v("结构，每个条目表示一个方法，一个实例初始化方法，或者一个类初始化方法。数组中的任意两个条目都不可能有相同的名称和描述符。field_info结构如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("    method_info { \n        // 掩码标记，指示访问权限以及属性\n        // ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED、ACC_STATIC\n        // ACC_FINAL、ACC_SYNCHRONIZED、ACC_BRIDGE、ACC_VARARGS\n        // ACC_NATIVE、ACC_ABSTRACT、ACC_STRICT、ACC_SYNTHETIC\n        u2 access_flags; \n\n        // 指向常量池中一个表示方法，<init>方法或者<clinit>方法的CONSTANT_Utf8_info结构\n        u2 name_index;\n\n        // 指向常量池中一个表示方法描述符的CONSTANT_Utf8_info结构\n        u2 descriptor_index; \n\n        // 方法额外属性数组的大小\n        attributes_count;\n\n        // attribute_info结构的数组\n        attribute_info attributes[attributes_count]; \n    }\n")])])]),n("p",[t._v("attributes被用在class文件，field_info，method_info，Code_attribute，record_component_info结构中。field_info结构如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("    attribute_info {\n        // 指向常量池中一个表示属性名的CONSTANT_Utf8_info结构\n        u2 attribute_name_index; \n\n        // 表示附加属性的字节长度\n        u4 attribute_length;\n\n        // 附加属性\n        u1 info[attribute_length];\n    }\n")])])]),n("p",[t._v("附加属性相关的东西就说来话长了，有时间在写吧。")])])}),[],!1,null,null,null);e.default=a.exports}}]);